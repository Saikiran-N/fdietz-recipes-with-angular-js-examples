# Angular Architecture

This article will present strong opinions about "the" way to organize Angular.js applications by visualizing the Angular framework as a Model-View-ViewModel architecture. It will suggest libraries that complement this architecture and patterns of usage that simplify design. Before proceeding, I will note once and then never again, that this is of course only one way to organize your Angular applications, and that Angular describes itself as "Model-View-Whatever," suggesting that your architecture may be much more liberal than the ideas presented here, but I believe that new Angular architects will benefit from explicit recommendations to either adopt or rebel against.

## Model-View-ViewModel

An Angular application may be usefully seen as a Model-View-ViewModel architecture. In MVVM design (and most MV-W patterns), the Model, your application data and application-specific logic, is king. "Fat model" design, in which the majority of your application-specific logic is handled in the Model, and thus shared between all views and controllers, works very well in Angular as it does in MVC architectures; it keeps code DRY and reusable.

Views, your templates, are written in plain HTML, and HTML is extended by Angular directives--HTML elements and attributes that you create to serve your application's needs. Angular directives _can_ be highly application-specific, and bound tightly to your Model, but my experience building enterprise-scale Angular applications has led me to the rule that directives should primarily, if not only, to create new methods of interaction--flipbooks, show-hide panels, forward and back buttons, and the like. Interaction-focused directives are reusable, while directives coupled tightly to your data, are not, as is often the case with tight coupling of any kind.

The ViewModel is often the least-understood portion of this architecture. It is akin to the Document Object Model (DOM) and Browser Object Model (BOM), which represent the onscreen "document," and "browser window" respectively. The DOM and BOM are Javascript model like any other--they represent a particular object type--the way that classical languages traditionally model Users, Posts, Comments, and so forth. The DOM, however, is built to represent static documents like newspapers, press releases, magazines, and the all the other traditional web "page" types that have classically represented a majority of the Internet. They represent pages of various media, but pages are static, not dynamic, the way rich desktop applications (and now web applications like Rdio and Google Maps) are. The ViewModel is a representation of a dynamic web _application_, like a music player or a suite of marketing tools. 

The ViewModel is organized hierarchically, like the DOM, and often directly mirrors the DOM in structure. This is because the ViewModel is declared via directives, our custom HTML elements and attributes that we add, in our views, to DOM elements. Directives create `$scopes`, the different planes in the hierarchy, which are nested within one another like DOM elements, and may inherit data and behavior from their parent elements. The ViewModel may create a header section with a search bar, a sidebar with various options to select, and a main content section in a similar fashion to the DOM--the difference between the ViewModel and the Document Object Model in specific is that the ViewModel exposes our application-specific data, behavior, and hierarchy, while the Document Model only represents the hierarchical organization of our page, in the way a static document separates levels of organization, too.

Elements in the view fire events on the behaviors the ViewModel exposes--if a ViewModel exposes a button to create a new playlist, and the user clicks that view element, the function exposed on the ViewModel's `$scope` will trigger. With few exceptions, the ViewModel should act as an intermediary to the Model itself; often the behaviors we want to expose on the ViewModel are the behaviors of a Model object itself. In the case of creating a new playlist, the ViewModel should expose the Playlist model's `new` function, a predictable function that all models should share. The Model also fires events on the ViewModel; when the Playlist object fires the event `new`, the ViewModel can be set to respond by creating a new representation of that playlist in the sidebar, which in creates a new View element. Angular's built-in functionality will often take care of this "listening and responding" functionality for us if we know how to tap into it. If a user's playlists are set to be displayed in from newest to oldest in our music player's sidebar via an `ng-repeat`, this built-in directive will respond to a new playlist's creation in `user.playlists`, and automatically add the new playlist to the top of the sidebar. That's the magic of Angular's data-binding mechanisms, and they will help us achieve our goals without reinventing the wheel once we know how to utilize them.

## The Model: That All-Important Missing Piece

I've told you that Angular provides excellent mechanisms for extending the palette of HTML (directives), and excellent mechanisms to mediate interactions between models and views (`$scopes` and two-way data binding). I've also told you that the Model is the most important part of a strong Angular architecture, and unfortunately, Angular falls desperately short in this area (at least out-of-the-box). 

A useful base class for our models must have built-in functionality to:

1) Handle common types of validations, like length, presence, and common formats
2) Describe and find the relationships between models, like the comments that belong to a post, or the playlists that belong to a user
3) Configure our models to asynchronously load data from RESTful APIs
4) Represent instances of a given model
5) Persist new data, and update old data using our API
6) Group logic and behavior that all model instances share

Unfortunately, the built-in Model creation service, `$resource`, is only really built to handle numbers 3, 4, and 5. We can extend classes created with `$resource` to group logic and behavior particular to our models, but not in an intuitive, class-centric manner (they will not be organized under constructor functions, which is the common paradigm in Javascript for representing "classes"). 

## ActiveResource: The Missing Library

Several libraries exist for modeling in Angular. Full disclosure: I created my own, ActiveResource, because the others (like restAngular and AngularFire), exist only to perfect the solutions to numbers 3, 4, and 5 that Angular's `$resource` provides us with out-of-the-box, and to provide access to real-time backends, like Firebase. They do things like fix bugs, use promises, and provide support for all HTTP methods, but they do not begin to build an Object-Relational Mapper, which centralizes application logic in the Model, and allows for a strict adherence to the MVVM patterns I described above. They continue to necessitate duplication of logic across the application--for instance, validations in default Angular are handled through directives, set on individual field inputs, which do not prevent a user from persisting invalid data--logic that should be bundled into the default saving and updating functionality common to all models. They allow us to style errors, but not to use the logic associated with those errors throughout our application. Moreover, they necessitate extraordinary duplication among models themselves--loading relationships between two models must be done for every model pairing; common methods for persistence must be created on every single Model. A well-tested application without shared model logic quickly becomes untenable--as each of these models must test that invalid objects are not persisted, that the `save` function of each model works as expected, and that associations are lazily loaded to avoid bogging down our poor single-threaded browser with unnecessary HTTP requests. 

ActiveResource solves these problems so you don't have to. 

## Fat View

One common, and well-founded counter-argument to providing anything other than a RESTful API consumer (like `$resource`, restAngular, or Firebase) is that the View should not duplicate the Model logic of the server. The server _must_ handle _all_ Model logic, since many modern applications share these data sources among web applications, apps native to tablets and phones, and other hardware units in certain types of enterprise applications (like home security systems). 

The argument against the "Fat View" is also one of avoiding duplication, which will cause all sorts of untold nightmares when changes must be made in multiple places--the same argument I make for providing all of this functionality in a common model base class. This argument is a strong one, and one that should be weighed carefully. Any logic that exceeds beyond persistence, validations, and relationships on the client is likely to be duplicated logic that will cause future headaches. If you have an endpoint setup to handle certain logic on the backend, by all means, you should utilize it, not duplicate it.

This type of logic, however, is "business logic," not "architecture logic." Architecture logic, like when to load associated resources that the model object currently displayed to the user relies on need to be loaded, _would_ have to be duplicated on the client _no matter what_, and without a shared base class, would be duplicated in many places. Certain logic, like validations, could arguably be considered "business logic," and my case for adding it to the client is one of performance and user experience--if the client can determine whether or not an instance is valid before saving it, it can present errors to the user as soon as the user makes them, avoid unnecessary HTTP requests that slow the experience down, and avoid the classic "waiting for a response from the server causes you to have to re-fill out that form anyway" response. By abstracting validation logic to directly mimic Ruby on Rails' validations, ActiveResource provides a concise and predictable interface for describing what I believe to be a necessary addition to the user experience. Model-centric validations also ensure that we don't duplicate these validations in the view, for many instances of the same model in different forms. 