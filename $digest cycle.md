# $digest cycle

Angular's sexy, magical appeal arguably centers around its `{{two-way binding}}` between the View and the ViewModel (if you conceive of Angular as a Model-View-ViewModel framework). If a user interacts with a UI element, like a form input, and that UI element is bound to the `$scope` (the ViewModel), then the changes automatically propagate to the other elements on the page that are bound to the same `$scope` attribute. We've all seen the classical Angular examples that save us from writing asynchronous requests, but how exactly does this magic work?

#### How the $digest cycle works

As in a traditional observer pattern (or a Twitter account/subscriber-styled pattern), all parties interested in receiving notifications from a given user; let's say that user is `project.title`, where project represents a particular project, not the Project model--or the "idea" of a project. If some of the elements on the page are responsible for keeping track of the value of `project.title`, either because they are responsible for showing the current value of `project.title` or because they are responsible for telling others the value of `project.title`, should the value change, then these elements "subscribe" to `project.title`--they register a `$watch`(er) to keep tabs on `project.title`. 

`$watch`ers are built in to Angular, and any time we use one of Angular's built-in functionalities where a `$watch`er would be needed (like a binding or an ng-model attribute), Angular registers a `$watch`er for us. We don't need to worry about registering `$watch`ers, because Angular knows that type of element would use a `$watch`. When Angular first loads our app, it goes through a compilation cycle, which first asks the HTML for all the directives (the compile phase), then takes the link functions from each of the directives and injects the `$scope` into them--setting up data-bindings and registering `$watch` as necessary. 

Then, whenever any `$watch` reports a change (let's say we edit `project.title` using a form with an `ng-model` of `project.title`), the entire `digest` cycle goes off--signalling to other `$watch` that an update may be important to them. During this cycle's course, the application asks each `$watch` whether or not they have to update (because they too are bound to `project.title`). When no more elements need to update, the `$digest` loop exits, and the DOM updates appropriately, filling in the new value on each element that reported a change. All of this happens nearly instantaneously, and the process of checking each element for change is called dirty-checking. 

#### Registering our own $watch

Maybe it jumped out at you previously, but Angular is only creating `$watch` when we're using a built-in Angular service like data-binding, not when we make up our own directives. Let's say we create an image picker directive, where we assign `project.image` to the value of the picture picked by the user. Even though the value of `project.image` has changed on the ViewModel, Angular hasn't auto-added any `$watch` for us, so the `$digest` loop never begins, and we don't see our update reflected in our image placeholder that's bound with `ng-src` (it had registered a `$watch`, but `project.image` hasn't reported a new value, so it doesn't know that the value has changed). 

To register our own watch, and to force a `$digest` cycle, we can call `$scope.$apply();`. A word of warning: `$apply()` should only be called in a directive (not in controllers, since apply() are able to run into one another in controllers, and can cause errors), and should be used instead of `$watch()` or `$digest()` (which do much the same thing), since `$apply()` runs with error handling. 